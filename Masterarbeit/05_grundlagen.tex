\chapter{Grundlagen}
\label{sec:grundlagen}


\section{Software-Qualität}
\label{sec:softwarequalität}

Nahezu jeder Programmierer ist schon einmal mit dem Begriff der Software-Qualität in Berührung gekommen. Diesen Qualitätsbegriff jedoch genau zu erfassen, erweist sich als schwierig.
Die DIN-ISO-Norm 9126 definiert Software-Qualität wie folgt:
\\
\glqq Software-Qualität ist die Gesamtheit der Merkmale und Merkmalswerte eines Software-Produkts, die sich auf dessen Eignung beziehen, festgelegte Erfordernisse zu erfüllen.\grqq \cite{iso/iec_iso/iec_2001}
\\
Im Jahr 2005 ist die DIN-ISO-Norm 9126 von der DIN-ISO-Norm 25010 \cite{iso/iec_iso/iec_2011} abgelöst worden. Die Definition der neuen Norm unterscheidet sich von der alten Definition vor allem darin, dass nun die Erfüllung von Benutzerbedürfnissen und nicht mehr die Erfüllung von Erfordernissen im Vordergrund steht.\\
Folgt man der Analyse von Hoffmann \cite[vgl. S.6 ff.]{hoffmann_software-qualitat_2013} wird deutlich, dass es sich bei dem Begriff der Software-Qualität um eine multikausale Größe handelt. Das bedeutet, dass zur Bestimmung der Qualität einer Software nicht nur ein einzelnes Kriterium existiert. Vielmehr verbergen sich hinter dem Begriff eine ganze Reihe verschiedener Kriterien, die je nach den gestellten Anforderungen in ihrer Relevanz variieren.
Sammlungen solcher Kriterien werden in sogenannten Qualitätsmodellen zusammengefasst. Die DIN-ISO-Norm 25010 \cite{iso/iec_iso/iec_2011} bietet ein solches Qualitätsmodell und definiert damit eine Reihe von wesentlichen Merkmalen, die für die Beurteilung der Software-Qualität eine Rolle spielen. Die Merkmale der DIN-ISO-Norm 25010 \cite{iso/iec_iso/iec_2011} sind in Abbildung \ref{fig:qualitaetsmerkmaleVonSoftwaresystemen} zusammengefasst.
\begin{figure}[htb]
  \centering  
  \includegraphics[scale=0.7]{img/softwarequalitaet25010.png}\\
  \footnotesize\sffamily\textbf{Quelle:} \cite{iso/iec_iso/iec_2011}
  \caption{Qualitätsmerkmale von Softwaresystemen (ISO 25010)}
  \label{fig:qualitaetsmerkmaleVonSoftwaresystemen}
\end{figure}
Eine nähere Definition der einzelnen Begriffe des Qualitätsmodells kann beispielsweise dem Buch \grq Software-Qualität\grq\ von Dirk W. Hoffmann \cite[S.7 ff.]{hoffmann_software-qualitat_2013} entnommen werden.\\
Um die Qualität einer Software zu steigern, bietet die moderne Software-Qualitätssicherung laut Hofmann \cite[vgl. S.19 ff.]{hoffmann_software-qualitat_2013} eine Vielzahl von Methoden und Techniken:
Ein Teil der Methoden versucht durch eine Verbesserung des Prozesses der Produkterstellung die Entstehung von qualitativ hochwertigen Produkten zu begünstigen. Diese Methoden fallen in den Bereich der Prozessqualität.
Einen weiteren Bereich bilden die Methoden, die zur Verbesserung der Produktqualität dienen. Bei diesen Methoden wird das Softwareprodukt direkt bezüglich der Qualitätsmerkmale überprüft. Dieser Bereich unterteilt sich in die konstruktive und analytische Qualitätssicherung. Unter konstruktiver Qualitätssicherung versteht man z.B. den Einsatz von Methoden, Werkzeugen oder Standards, die
dafür sorgen, dass ein Produkt bestimmte Forderungen erfüllt. 
Unter analytischer Qualitätssicherung versteht man den Einsatz von analysierenden bzw. prüfenden Verfahren, die Aussagen
über die Qualität eines Produkts machen.
In diesem Bereich der Qualitätssicherung befindet sich unter anderem der klassische Software-Test. Eine Übersicht über das gesamte Gebiet der Software-Qualitätssicherung, wie es sich uns gegenwärtig darstellt, ist in Abbildung \ref{fig:softwareQualitätssicherung} dargestellt. 
\begin{figure}[htb]
  \centering  
  \includegraphics[scale=0.7]{img/softwarequalitaet.png}\\
  \footnotesize\sffamily\textbf{Quelle:} \cite[vgl. S.20]{hoffmann_software-qualitat_2013}
  \caption{Übersicht über das Gebiet der Software-Qualitätssicherung}
  \label{fig:softwareQualitätssicherung}
\end{figure}



\section{Softwaretest}
\label{sec:softwaretest}
Im Laufe der Zeit wurden viele Versuche unternommen, um die Qualität von Software zu steigern. Besondere Bedeutung hat hierbei der Software-Test erlangt.
Der IEEE Standard 610.12 definiert den Begriff Test als das Ausführen einer Software unter bestimmten Bedingungen mit dem Ziel, die erhaltenen Ergebnisse auszuwerten, also gegen erwartete Werte zu vergleichen.
(Im Original: \glqq An activity in which a system or component is executed under specific conditions, the results are observed or recorded, and an evaluation is made of some aspect of the system or component.\grqq\ \cite{ieee_ieee_1991})\\
Bereits zu Beginn der Softwareentwicklung wurde versucht, Programme vor ihrer Auslieferung zu testen. Der dabei erzielte Erfolg entsprach nicht immer den Erwartungen. Im Laufe der Jahre wurde das Testen daher auf eine immer breitere Grundlage gestellt. Es entwickelten sich Unterteilungen des Software-Tests, die bis heute Bestand haben. Thaller \cite[vgl. S.18]{thaller_software-test_2002} nennt hier beispielsweise:
\begin{itemize}
\item White-Box-Test
\item Black-Box-Test und externe Testgruppe
\item Volume Test, Stress Test und Test auf Systemebene
\end{itemize}
Jeder dieser Begriffe beschreibt bestimmte Techniken, die bei konsequenter Anwendung dazu führen können, Fehler in Softwareprodukten zu identifizieren. 

Nach Hoffmann \cite[vgl. S.22]{hoffmann_software-qualitat_2013} spielt neben der Auswahl der richtigen Techniken für ein bestimmtes Problem in der Praxis die Testkonstruktion eine zentrale Rolle. Bereits für kleine Programme ist es faktisch nicht mehr möglich das Verhalten der Software für alle möglichen Eingaben zu überprüfen. Es muss sich daher immer auf eine vergleichsweise geringe Auswahl an Testfällen beschränkt werden. Testfälle unterscheiden sich jedoch stark in ihrer Relevanz. Die Auswahl der Testfälle hat daher einen großen Einfluss auf die Anzahl der gefundenen Fehler und damit auch auf die Qualität des Endprodukts. 

Laut Hofmann \cite[vgl. S.22]{hoffmann_software-qualitat_2013} ist der Software-Test eine der verbreitetsten Techniken zur Verbesserung der Software-Qualität. Um über lange Sicht gute Software produzieren zu können, reicht es jedoch nicht aus, sich nur auf eine Technik der Software-Qualitätssicherung zu stützen. Ein großer Nachteil des Software-Tests ist laut Thaller \cite[vgl. S.18]{thaller_software-test_2002}, dass Fehler erst in einer relativ späten Phase der Entwicklung identifiziert werden. Je später ein Fehler jedoch erkannt wird, desto teurer wird auch seine Beseitigung. Abbildung \ref{fig:softwareQualitätssicherung} zeigt, dass der Software-Test nur eine von vielen Techniken des Qualitätsmanagement darstellt. Um eine möglichst qualitativ hochwertige Software zu erhalten, ist es daher ratsam, sich bei der Qualitätssicherung möglichst breit aufzustellen und sich nicht nur auf die analytische Qualitätssicherung in Form des Software-Tests zu verlassen. 


\section{Testautomatisierung}
\label{sec:testautoGrundlagen}
Das Testen von Software macht in heutigen Projekten einen großen Teil der Projektkosten aus. So sprechen beispielsweise Harrold \cite{harrold_testing:_2000} und auch Ramler \cite{ramler_economic_2006} davon, dass das Testen für 50\% 
und mehr der gesamten Projektkosten verantwortlich sein kann. 
Mit steigender Komplexität der Software müssen, um eine konstante Qualität der Software zu gewährleisten, immer höhere Ausgaben für das Testen getätigt werden.  
Um diese Kosten zu reduzieren, haben sich im Laufe der Zeit die bestehenden Testmethoden immer weiter entwickelt und auch neue Ansätze herausgebildet. Harrold \cite{harrold_testing:_2000} beschreibt als einen Ansatz, Software-Tests möglichst automatisiert durchzuführen. Diesen Ansatz fast man mit dem Begriff Testautomatisierung zusammen.
Seidl et al. \cite[S.7]{seidl_basiswissen_2012} definieren Testautomatisierung als \glqq die Durchführung von ansonsten manuellen Testtätigkeiten durch Automaten.\grqq\
Diese Definition zeigt, dass das Spektrum der Testautomatisierung breit gefächert ist. Testautomatisierung beschränkt sich nicht nur auf das automatisierte Durchführen von Testfällen, sondern erstreckt sich über alle Bereiche des Software-Tests. Die verschiedenen Möglichkeiten der Testautomatisierung werden in Kapitel \ref{sec:bereiche_der_testautomatisierung} dargestellt.
Aus Sicht des Qualitätsmanagement ist die Testautomatisierung sowohl den Methoden zur Steigerung der Produktqualität als auch der Prozessqualität zugeordnet. Ein automatisierter Software-Test hat immer noch den selben Charakter wie ein manueller Software-Test und ist daher ein Teil der analytischen Qualitätssicherung. Allerdings erfordert Testautomatisierung laut Hoffmann \cite[vgl. Seite 25]{hoffmann_software-qualitat_2013} auch immer infrastrukturelle Anpassungen. Automatisierte Testfälle benötigen in der Regel eine besondere Software-Infrastruktur, wie etwa ein Automatisierungsframework. Solche Maßnahmen, die den Programmentwickler aus technischer Sicht in die Lage versetzen, seiner täglichen Arbeit in geregelter und vor allem produktiver Weise nachzugehen, werden den Methoden zur Verbesserung der Prozessqualität zugeordnet (siehe Abbildung \ref{fig:softwareQualitätssicherung}).



\section{Testprozess}
\label{sec:testprozess}

Um Software-Tests effektiv und strukturiert durchzuführen, wird ein feiner Ablaufplan für die einzelnen Testaufgaben benötigt. Diesen Ablaufplan fassen Splinner und Linz \cite{spillner_basiswissen_2007} im fundamentalen Testprozess zusammen. Die einzelnen Arbeitsschritte, die im Lebenszyklus eines Software-Tests anfallen, werden dabei verschiedenen Phasen zugeordnet.
Durch den Testprozess wird die Aufgabe des Testens in kleinere Testaufgaben untergliedert.

Testaufgaben, die Splinner und Linz \cite{spillner_basiswissen_2007} dabei unterscheiden sind:

\begin{itemize}
	  \itemsep0pt
      \item Testplanung und Steuerung
      \item Testanalyse und Testdesign
      \item Testrealisierung und Testdurchführung
      \item Testauswertung und Bericht
      \item Abschluss der Testaktivitäten       
\end{itemize}

Laut Seidl et al. \cite[S. 9]{seidl_basiswissen_2012} wird jeder, der strukturiert testet, diese Aktivitäten auf die eine oder andere Weise abbilden.\\
Splinner und Linz \cite[S.19]{spillner_basiswissen_2007} geben zu bedenken, dass obgleich die Aufgaben in sequenzieller Reihenfolge im Testprozess angegeben sind, können sie sich trotzdem überschneiden und teilweise auch gleichzeitig durchgeführt werden. \\ Auf Grundlage des fundamentalen Testprozesses nach Splinner und Linz \cite[S.20ff]{spillner_basiswissen_2007} werden im Folgenden die Teilaufgaben näher beschrieben. 
Diese Beschreibung wird durch Ausführungen von Seidl et al. \cite[S. 9 ff.]{seidl_basiswissen_2012}, vor allem bezüglich der Testautomatisierung, erweitert. 

\subsection{Testplanung und Steuerung}
\label{subsec:testplanung_und_steuerung}
Um dem Umfang und der Komplexität heutiger Software-Tests gerecht zu werden, benötigt man zu Beginn des Testprozesses eine genaue Planung.
Ziel dieser Planung ist es, den Rahmen für die weiteren Testaktivitäten festzulegen. Die Aufgaben und die Zielsetzungen der Tests müssen ermittelt wurden. Eine Ressourcenplanung wird benötigt und eine geeignete Teststrategie muss ermittelt werden. In Kapitel \ref{sec:softwaretest} wurde bereits erwähnt, dass das vollständige Testen einer Anwendung in der Regel nicht möglich ist. Die einzelnen Systemteile müssen daher nach Schwere der zu erwartenden Fehlerwirkung priorisiert werden. Um so schwerwiegender die zu erwartende Fehlerwirkung ist, um so intensiver muss der betrachtete Systemteil auch getestet werden. Ziel der Teststrategie ist also \glqq die optimale Verteilung der Tests auf die \frqq richtigen\flqq\ Stellen des Softwaresystems.\grqq\ \cite[S.21]{spillner_basiswissen_2007} \\ Steht das Softwareprojekt unter einem hohen Zeitdruck, müssen Testfälle zusätzlich priorisiert werden.
Um zu verhindern, dass das Testen zu einem endlosen Prozess wird, werden geeignete Testendekriterien festgelegt. Anhand dieser Kriterien kann später entschieden werden, ob der Testprozess abgeschlossen werden kann.

Bereits zu Beginn des Testprozesses werden auch wichtige Grundsteine für eine spätere Testautomatisierung gelegt. Es muss entschieden werden, in welchen Teststufen und Testbereichen eine Automatisierung eingesetzt werden soll. Vor allem ist die Frage zu klären, ob und in welchem Ausmaß eine Automatisierung überhaupt sinnvoll ist. Es kann durchaus vorkommen, dass eine Analyse ergibt, dass eine Testautomatisierung für ein Projekt unwirtschaftlich ist.
Entscheidet man sich für eine Testautomatisierung, hat das in der Regel große Auswirkungen auf die einzusetzenden Ressourcen und die zeitliche Planung und Aufwandsschätzung.
Oftmals wird im Rahmen der Tests eine besondere Werkzeugunterstützung oder Infrastruktur benötigt. Derartige Punkte müssen auch bereits in der frühen Planungsphase berücksichtigt werden.

Die gesamten erarbeiteten Rahmenbedingungen werden in einem Testkonzept dokumentiert.
Eine mögliche Vorlage für dieses Dokument bietet die internationale Norm IEEE 829-2008 \cite{ieee_ieee_2008}.
Neben der frühzeitigen Planung der Tests muss während des gesamten Testprozesses eine Steuerung erfolgen.
Hierfür werden die Ergebnisse und Fortschritte der Tests und des Projekts laufend erhoben, geprüft und bewertet. Werden Probleme erkannt, kann so rechtzeitig gegengesteuert werden. 

\subsection{Testanalyse und Testdesign}
\label{subsec:testanalyse_und_design}
In dieser Phase wird zunächst die Qualität der Testbasis überprüft. Alle Dokumente, die für die Erstellung der Testfälle benötigt werden, müssen in ausreichendem Detailgrad vorhanden sein. Mit Hilfe der qualitätsgesicherten Dokumente kann die eigentliche Testfallerstellung beginnen.
Anhand der Informationen aus dem Testkonzept und den Spezifikationen, werden mittels strukturierter Testfallerstellungsmethoden logische Testfälle erstellt. Diese logischen Testfälle können dann in einer späteren Phase konkretisiert werden, indem ihnen z.B. tatsächliche Eingabewerte zugeordnet werden. Für jeden Testfall müssen die möglichen Rand- und Vorbedingungen sowie ein erwartetes Ergebnis bestimmt werden.\\
In dieser Phase beginnen auch erste Aufgaben, die mit der Testautomatisierung in Zusammenhang stehen.
Abgestimmt auf die ausgewählten Automatisierungswerkzeuge und die zu testende Software, muss die Umgebung für die Testautomatisierung vorbereitet werden. Anhand der Vorgaben des Testkonzeptes können dann jene Testfälle und Testabläufe ausgewählt werden, die im Zuge der Testautomatisierung implementiert werden sollen. Hierbei wird noch einmal die technische Umsetzbarkeit geprüft. Bei der Auswahl der Testfälle sollte zu Beginn eine möglichst breite Testabdeckung angestrebt werden.
Problemfelder können dann später durch weitere Testfälle in der Tiefe getestet werden.

\subsection{Testrealisierung und Testdurchführung}
\label{subsec:testrealisierung_und_durchführung}
In diesem Schritt des Testprozesses werden aus den logischen Testfällen der vorangegangenen Phase konkrete Testfälle gebildet.
Diese werden anhand ihrer fachlichen und technischen Zusammengehörigkeit zu Testszenarien gruppiert und anhand der Vorgaben aus dem Testkonzept priorisiert.
Sobald die zu testende Software zur Verfügung steht, kann mit der Abarbeitung begonnen werden. Die dabei erhaltenen Ergebnisse werden vollständig protokolliert. Werden im Zuge der Durchführung Fehler aufgedeckt, muss darauf in geeigneter Weise reagiert werden. Es kann beispielsweise ein zuvor definierter Fehlerprozess gestartet werden.
Korrekturen und nachgehende Veränderungen am Testobjekt werden durch eine Wiederholung der Testläufe abgedeckt.\\
Aus Sicht der Testautomatisierung beginnt in dieser Phase die technische Umsetzung.
In vielen Fällen bedeutet das Programmiertätigkeit. Diese Programmiertätigkeiten sind wiederum anfällig für eigene Fehler und müssen daher in angemessener Weise selbst qualitätsgesichert werden. Auch bei der Testautomatisierung ist eine Zusammenfassung von Testfällen sinnvoll. Auf diese Weise kann man funktionalen und logischen Abhängigkeiten zwischen den Testfällen gerecht werden.
Nach der Implementierung können die geplanten Testfälle durchgeführt werden.
Gerade bei der Automatisierung ist eine genaue Protokollierung der Ergebnisse besonders wichtig.
Nur dadurch ist es später möglich, aufgetretene Fehler überhaupt zu lokalisieren.


\subsection{Testauswertung und Bericht}
\label{subsec:testauswertung_und_bericht}
In dieser Phase des Prozesses wird geprüft, ob die im Testkonzept definierten Testendekriterien erreicht wurden. Sind alle Forderungen erfüllt, kann es zu einem Abschluss der Testaktivitäten kommen. Kommt es zu Abweichungen im Bezug auf diese Kriterien, muss darauf entsprechend reagiert werden. Es können Fehlerkorrekturen durchgeführt werden oder neue Testfälle erstellt werden. Aber auch der umgekehrte Fall ist möglich. Es kann dazu kommen, dass Endekriterien nur mit unverhältnismäßig hohem Aufwand erreicht werden 
und daher bestimmte Testfälle entfallen oder Kriterien überdacht werden müssen.

Für die Testautomatisierung ist die wesentliche Aufgabe dieser Phase die Auswertung und Aufarbeitung der erhaltenen Ergebnisse. Automatisierte Tests generieren oftmals eine Fülle an Log-Dateien und Protokollen. Um aus diesen Ergebnissen die richtigen Schlüsse zu ziehen und sie für Dritte zugänglich zu machen, müssen sie in eine lesbare Form gebracht werden.

In jedem Fall muss über die erhaltenen Ergebnisse und das daraus resultierende Vorgehen ein Testbericht erstellt werden. Je nach Umfang und Phase der Tests kann dieser mehr oder weniger formal ausfallen. Für einen Komponententest reicht beispielsweise eine formlose Mitteilung. Höhere Teststufen erfordern einen formaleren Bericht.



\subsection{Abschluss der Testaktivitäten}
\label{subsec:abschluss_der_testaktivitäten}
Sind die Testaktivitäten beendet, sollten zum Schluss alle im Laufe des Testprozesses gemachten Erfahrungen analysiert werden. So können die gewonnenen Erkenntnisse für spätere Projekte genutzt werden. Dadurch kann eine stetige Verbesserung des Testprozesses erreicht werden.
Die während des Prozesses erstellten Testfälle, sowie alle sonstigen Ergebnisse, sollten archiviert werden. Auf diese Weise stehen sie für folgende Regressionstests zur Verfügung. Die Kosten für Wartung und Pflege der Software können damit gesenkt werden.
Bei der Testautomatisierung bedeutet das, die Wiederherstellbarkeit der Testumgebung und des Sourcecodes sicherzustellen.
\newline\\
Abschließend ist zu sagen, dass sich die Testautomatisierung in der Regel gut in einen bereits bestehenden Testprozess integrieren lässt. Sie wird allerdings \glqq den Prozess nicht verbessern oder gerade richten, sondern nur unterstützen.\grqq\ \cite[S.21]{seidl_basiswissen_2012} \\ Ist der Testprozess schon vor Einführung einer Automatisierung schlecht organisiert gewesen, wird er sich nach der Einführung nicht verbessern.
Die Testautomatisierung ist also nicht als Heilmittel für schlecht laufende Prozesse gedacht, sondern als Möglichkeit einen bereits gut etablierten Prozess effizienter und effektiver zu gestalten.

\section{Vorgehensmodelle}
\label{sec:vorgehensmodelle}
Der in Kapitel \ref{sec:testprozess} beschriebene Testprozess ist nicht als losgelöster, eigenständiger Prozess zu betrachten. Vielmehr ist der Testprozess immer ein Teil eines größeren Entwicklungsablaufes bei der Erstellung eines Softwareproduktes. Einen solchen Entwicklungsablauf versucht man mit Hilfe von sogenannten Softwareentwicklungsmodellen, auch Vorgehensmodelle genannt, abzubilden.
Ein Projekt wird dazu in einzelne Phasen untergliedert, an deren Ende ein gewisses Ziel bzw. Ergebnis steht.
Auf gröbster Ebene lassen sich die Abläufe auf vier Hauptphasen reduzieren. Diese Phasen finden sich mehr oder weniger ausgeprägt in den meisten der gängigen Vorgehensmodelle wieder und werden auch so von Seidl et al. \cite[S.21 ff.]{seidl_basiswissen_2012} verwendet:

\begin{itemize}
\item Spezifikation
\item Design
\item Entwicklung
\item Test
\end{itemize}

Das Testen, bzw. der Testprozess ist eine von mehreren Phasen in einem solchen Entwicklungsmodell.
Es gibt eine Vielzahl von unterschiedlichen Softwareentwicklungsmodellen. Der Hauptunterschied liegt meist in der zeitlichen Koppelung und der inhaltlichen Ausprägung der einzelnen Phasen. Die einzelnen Phasen können sich innerhalb eines Vorgehensmodells überschneiden und wiederholen und müssen auch nicht immer, wie in der Auflistung angegeben, sequenziell abgearbeitet werden.
Aus der Sicht der Testautomatisierung ist nach Seidl et al. \cite[vgl. S.21 ff.]{seidl_basiswissen_2012} eine Einteilung der verschiedenen Vorgehensmodelle in zwei Gruppen sinnvoll: 

\begin{itemize}
\item Klassische Entwicklungsmodelle, die eher sequentiell ausgerichtet sind
\item Iterative und agile Entwicklungsmodelle, die sich durch Parallelisierung und kurze Iterationen auszeichnen.
\end{itemize}

\subsection{Klassische Entwicklungsmodelle}
\label{subsec:klassische_entwicklungsmodelle}

Die hier als klassische Entwicklungsmodelle betitelten Vorgehensmodelle zeichnen sich vor allem dadurch aus, dass die einzelnen Phasen sequenziell ausgeführt werden. Der bekannteste Vertreter dieser Vorgehensmodelle ist das Wasserfallmodell \cite{royce_managing_1987}. In diesem Modell sind alle Phasen strikt voneinander getrennt. Eine neue Phase kann erst begonnen werden, wenn eine vorangegangene Phase abgeschlossen wurde. Rücksprünge in vorangegangenen Phasen sind unerwünscht. In der Praxis wird dieses Vorgehen, laut Seidl et al. \cite[vgl. S.22]{seidl_basiswissen_2012}, jedoch oft nicht ganz so strikt umgesetzt. Es kommt zu Mischformen, bei denen die einzelnen Phasen nicht mehr voll sequenziell abgearbeitet werden, sondern sich teilweise überlagern. Vor allem im Bereich des Testens geht man oft zu einer solchen Mischform über. Das Testen ist meist keine getrennte Phase am Ende des Entwicklungsprozesses, sondern erstreckt sich über den gesamten Prozess ausgehend von der frühen Spezifikationsphase. Mögliche Ausprägungen klassischer Entwicklungsmodelle sind in Abbildung \ref{fig:verschiedene_auspraegungen_klassischer_entwicklungsmodelle} dargestellt.

\begin{figure}[htb]
  \centering  
  \includegraphics[scale=0.7]{img/sequentielleentwicklungsmodelle.png}\\
  \footnotesize\sffamily\textbf{Quelle:} \cite[vgl. S.22]{seidl_basiswissen_2012}
  \caption{Verschiedene Ausprägungen klassischer Entwicklungsmodelle}
  \label{fig:verschiedene_auspraegungen_klassischer_entwicklungsmodelle}
\end{figure}

Seidl et al. \cite[vgl. S.22]{seidl_basiswissen_2012} stellen fest, dass in Projekten, in denen ein sequenzielles Vorgehen gewählt wird, bereits in der frühen Planungsphase des Testprozesses genau abzuwägen ist, ob eine Automatisierung der Testfälle überhaupt sinnvoll ist.
Wenn zu Beginn des Projektes schon klar ist, dass die Testfälle nur ein einziges Mal, am Ende des Entwicklungsprozesses, ausgeführt werden, steht eine Automatisierung oft nicht in Relation zu den erhöhten Kosten, die bei der Erstellung der Tests anfallen würden.
Es ist allerdings zu beachten, dass Software meist mit dem Ende eines Projektes nicht seinen finalen Stand erreicht hat. Fehler sowie geänderte Anforderungen führen meist dazu, dass sich Softwareprodukte ständig weiterentwickeln.
Diese Weiterentwicklung ist zwangsläufig mit Codeänderungen verbunden, die wiederum zu Fehlern in bereits bestehendem Code führen können.
Um solche Fehler zu entdecken müssen im Rahmen von Regressionstests auch Testfälle wiederholt werden, die bereits erfolgreich abgeschlossen wurden.
Solche Regressionstests lassen sich bei einer vorhandenen Testautomatisierung besonders leicht durchführen. Sind also in der Software nach Projektabschluss größere Änderungen zu erwarten, kann sich eine Automatisierung über längere Sicht durchaus lohnen.
Neben Regressionstests kann nach Seidl et al. \cite[vgl. S.23]{seidl_basiswissen_2012} auch die Notwendigkeit einer höheren Testtiefe oder einer breiteren Testabdeckung ein Faktor sein, sich für eine Automatisierung zu entscheiden.
In manchen Fällen wie beispielsweise Lasttests, mit mehreren hundert Usern, kann eine Automatisierung auch unabdingbar werden.

\subsection{Iterative und agile Entwicklungsmodelle}
\label{subsec:iterative_und_agile_entwicklungsmodelle}
Als weitere Gruppe der Vorgehensmodelle nennen Seidl et al. \cite[vgl. S.23 ff.]{seidl_basiswissen_2012} die iterativen und agilen Entwicklungsmodelle.\\
Im Gegensatz zu den klassischen Entwicklungsmodellen sind in iterativen Modellen Rücksprünge in vorangegangene Phasen explizit erlaubt. Eine oder alle Phasen werden in diesen Modellen wiederholt durchlaufen. Auf diese Weise kann das Softwareprodukt inkrementell wachsen. Durch ein derartiges Vorgehen ist es einfacher möglich, auf den Umstand zu reagieren, dass sich Anforderungen in Softwareprojekten häufig ändern. \\
Auch agile Vorgehensmodelle leben von solch einem iterativen Vorgehen. Die einzelnen Phasen werden in kleinen Zyklen viele Male durchlaufen.
Ein bekannter Vertreter der agilen Methoden ist Scrum \cite{schwaber_agile_2002}. In Scrum wird ein Softwareprodukt in kurzen, sogenannten Sprints realisiert. Innerhalb eines Sprints wählt das Team selbständig eine Teilaufgabe des Projekts aus. Diese Teilaufgabe wird spezifiziert, entworfen, entwickelt und getestet. Am Ende eines Sprints steht ein Softwareprodukt, welches um einen weiteren Baustein ergänzt wurde.
Der Sprint ist das zentrale Element dieses Prozessmodells und kennzeichnet eine Iteration.
Abbildung \ref{fig:verschiedene_auspraegungen_iterativer_und_agiler_entwicklungsmodelle} zeigt verschiedene Ausprägungen iterativer und agiler Entwicklungsmodelle.\\
\begin{figure}[htb]
  \centering  
  \includegraphics[scale=0.8]{img/iterativeentwicklungsmodelle.png}\\
  \footnotesize\sffamily\textbf{Quelle:} \cite[vgl. S.24]{seidl_basiswissen_2012}
  \caption{Verschiedene Ausprägungen iterativer und agiler Entwicklungsmodelle}
  \label{fig:verschiedene_auspraegungen_iterativer_und_agiler_entwicklungsmodelle}
\end{figure}
Für das Testen stellen diese kurzen Iterationen laut  Seidl et al. \cite[vgl. S.24]{seidl_basiswissen_2012} ein Problem dar.
Jeder Entwicklungszyklus bringt neue Features hervor, die mit Testfällen abgedeckt werden müssen. Der agile Charakter in diesen Vorgehensmodellen bedingt, dass sich Anforderungen ständig ändern und somit auch bereits fertiger Code oft angepasst werden muss. Darüber hinaus ist nicht ausgeschlossen, dass neue Features Auswirkungen auf alten Code haben können. Neben den neu implementierten Teilen muss daher zum Ende einer jeden Iteration auch sämtlicher alter Code getestet werden.
Dies bedingt einen enormen zusätzlichen Testaufwand. 
In agilen Vorgehensmodellen, wie Scrum, ist der Testaufwand nach wenigen Sprints bereits oft so hoch, dass ein Testdurchlauf zusammen mit allen Regressionstests manuell nicht mehr zu bewältigen ist.
Gerade in Projekten, die einem derartigen Vorgehensmodell folgen, ist es daher sinnvoll Testautomatisierung einzusetzen. Einmal implementierte Testfälle können zum Ende einer jeden Iteration erneut ausgeführt werden. Die höheren Kosten, die bei der Automatisierung entstehen, sind so schnell amortisiert.\\
Das sich ständig ändernde Testobjekt bedingt nicht nur die Notwendigkeit von automatisierten Testfällen, sondern erhöht gleichzeitig auch die Anforderungen an die Qualität. Häufige Änderungen am zu testenden Code lassen einmal implementierte Testfälle schnell veralten. Es muss daher bei der Erstellung der automatisierten Tests besonders auf die Wartbarkeit geachtet werden.
Testfälle sollten möglichst robust in ihrem Design sein, um nicht schon bei kleinen Änderungen zerstört zu werden. Der Qualitätsstandard sollte den gleichen Anforderungen unterliegen, der bereits für den vorhandenen Code verwendet wurde. Anpassungen werden sonst zu zeitaufwendig. Die Pflege der bereits implementierten Testfälle ist dann nicht mehr wirtschaftlich und die Akzeptanz der Tests im Projekt sinkt.
